<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Perspective Scene with Glowing Windows</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #add8e6; /* baby blue */
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: pointer;
    }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
  const scene = new THREE.Scene();
  scene.background = new THREE.Color('#add8e6');

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 3, 10);

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const dirLight = new THREE.DirectionalLight(0xffffff, 1);
  dirLight.position.set(5, 10, 5);
  scene.add(dirLight);

  const ambientLight = new THREE.AmbientLight(0x666666);
  scene.add(ambientLight);

  // Buildings with glowing yellow windows (yellow squares + bigger transparent glow planes behind)
  const buildingCount = 12;
  const startZ = 0;
  const spacingZ = -6;
  const baseHeight = 4;

  for (let i = 0; i < buildingCount; i++) {
    const zPos = startZ + i * spacingZ;
    const scale = 1 - i * 0.08;
    const opacity = 1 - i * 0.09;

    // Building
    const buildingMaterial = new THREE.MeshStandardMaterial({
      color: 0x444444,
      flatShading: true,
      transparent: true,
      opacity: opacity,
    });

    // Left building
    const leftBuilding = new THREE.Mesh(
      new THREE.BoxGeometry(2 * scale, baseHeight * scale, 4 * scale),
      buildingMaterial
    );
    leftBuilding.position.set(-5, baseHeight * scale / 2, zPos);
    scene.add(leftBuilding);

    // Right building
    const rightBuilding = new THREE.Mesh(
      new THREE.BoxGeometry(2 * scale, baseHeight * scale, 4 * scale),
      buildingMaterial
    );
    rightBuilding.position.set(5, baseHeight * scale / 2, zPos);
    scene.add(rightBuilding);

    // Window sizes
    const windowSize = 0.3 * scale;
    const glowSize = windowSize * 2.5;
    const windowsPerBuilding = 8;

    // Helper: create glowing window (yellow square + glow plane behind)
    function createGlowingWindow(x, y, z, rotationY) {
      // Main bright yellow window
      const windowMat = new THREE.MeshBasicMaterial({ color: 0xffee44 });
      const windowGeo = new THREE.PlaneGeometry(windowSize, windowSize);
      const windowMesh = new THREE.Mesh(windowGeo, windowMat);
      windowMesh.position.set(x, y, z);
      windowMesh.rotation.y = rotationY;
      scene.add(windowMesh);

      // Glow plane behind window (larger, transparent yellow, no lighting)
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0xffee44,
        transparent: true,
        opacity: 0.3,
        depthWrite: false,
      });
      const glowGeo = new THREE.PlaneGeometry(glowSize, glowSize);
      const glowMesh = new THREE.Mesh(glowGeo, glowMat);
      glowMesh.position.set(x, y, z - 0.01 * Math.sign(rotationY)); // slightly behind window
      glowMesh.rotation.y = rotationY;
      scene.add(glowMesh);
    }

    // Left windows (front face = +z)
    for (let w = 0; w < windowsPerBuilding; w++) {
      const yPos = 0.3 + w * (windowSize + 0.05);
      createGlowingWindow(
        -5 + 1.01 * scale,
        yPos,
        zPos + 1,
        -Math.PI / 2
      );
    }

    // Right windows (front face = +z)
    for (let w = 0; w < windowsPerBuilding; w++) {
      const yPos = 0.3 + w * (windowSize + 0.05);
      createGlowingWindow(
        5 - 1.01 * scale,
        yPos,
        zPos + 1,
        Math.PI / 2
      );
    }
  }

  // Base platform below computer
  const baseGeometry = new THREE.BoxGeometry(7, 0.5, 4);
  const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
  const base = new THREE.Mesh(baseGeometry, baseMaterial);
  base.position.set(0, -0.25, 0);
  scene.add(base);

  // Computer (screen)
  const computerGeometry = new THREE.BoxGeometry(4, 2.5, 0.2);
  const computerMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
  const computer = new THREE.Mesh(computerGeometry, computerMaterial);
  computer.position.set(0, 1.25, 0);
  scene.add(computer);

  // Keyboard keys on base: small boxes arranged in rows
  const keyRows = 3;
  const keyCols = 8;
  const keyWidth = 0.3;
  const keyHeight = 0.1;
  const keyDepth = 0.2;
  const keySpacingX = 0.35;
  const keySpacingY = 0.25;

  for (let row = 0; row < keyRows; row++) {
    for (let col = 0; col < keyCols; col++) {
      const keyGeometry = new THREE.BoxGeometry(keyWidth, keyHeight, keyDepth);
      const keyMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
      const key = new THREE.Mesh(keyGeometry, keyMaterial);

      const xPos = - (keyCols / 2) * keySpacingX + col * keySpacingX + keySpacingX / 2;
      const yPos = 0.3 + row * keySpacingY;
      const zPos = 0.8;

      key.position.set(xPos, yPos, zPos);
      base.add(key);
    }
  }

  // Register Button - Canvas texture for text
  const buttonCanvas = document.createElement('canvas');
  buttonCanvas.width = 256;
  buttonCanvas.height = 128;
  const ctx = buttonCanvas.getContext('2d');

  function roundRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.fill();
  }

  ctx.fillStyle = '#007bff'; // blue button
  roundRect(ctx, 10, 10, 236, 108, 20);

  ctx.font = 'bold 28px Arial';
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('Register Now', buttonCanvas.width / 2, buttonCanvas.height / 2);

  const buttonTexture = new THREE.CanvasTexture(buttonCanvas);
  const buttonMaterial = new THREE.MeshBasicMaterial({ map: buttonTexture, transparent: true });
  const buttonGeometry = new THREE.PlaneGeometry(2, 1);
  const registerButton = new THREE.Mesh(buttonGeometry, buttonMaterial);
  registerButton.position.set(0, 0, 0.11);
  computer.add(registerButton);

  // Snow particles
  const snowCount = 800;
  const snowGeometry = new THREE.BufferGeometry();
  const snowPositions = [];
  for (let i = 0; i < snowCount; i++) {
    snowPositions.push(
      (Math.random() - 0.5) * 100,
      Math.random() * 30,
      (Math.random() - 0.5) * 100
    );
  }
  snowGeometry.setAttribute('position', new THREE.Float32BufferAttribute(snowPositions, 3));
  const snowMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
  const snow = new THREE.Points(snowGeometry, snowMaterial);
  scene.add(snow);

  // Raycaster for button clicks
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  function onClick(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObject(registerButton);
    if (intersects.length > 0) {
      alert('Register button clicked!');
    }
  }

  window.addEventListener('click', onClick);

  // Animate
  function animate() {
    requestAnimationFrame(animate);

    // Snow fall
    const pos = snowGeometry.attributes.position.array;
    for (let i = 1; i < pos.length; i += 3) {
      pos[i] -= 0.05;
      if (pos[i] < -2) pos[i] = 20;
    }
    snowGeometry.attributes.position.needsUpdate = true;

    renderer.render(scene, camera);
  }

  animate();

  // Resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
